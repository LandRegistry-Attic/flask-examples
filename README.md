How to structure a Flask app
=================

### Configuration

Create a config.py with a base Config class  and a sub class per environment that  needs over riding of values, or additional values.

Values for configuration keys should be read from the environment. In other words set environment variables for local development and on any deployment target.

For example, for local development

```
export SETTINGS='config.Config'
```

or on Heroku:

Install [Heroku Toolbelt](https://toolbelt.heroku.com/) , then you can set what config to use as follows.

```
heroku config:set SETTINGS=config.HerokuConfig
```


### To run the application

The app should have a procfile Procfile which in this app looks like this:

```
web: gunicorn -k eventlet appname.server:app
```

There may be a higher level Procfile to run a number of services. In that case create a run.sh and add that to project Procfile


### Databases

If the app connects to a database then we'll need a means to create and manage db schemas. The suggested approach would be to add Flask-Migrate to your and Flask-Script to the projects requirements.txt. Flask-Migrate will pull in Flask-SQLAlchemy and Alembic (manages the actual migration). Flask-Script provides a nice wrapper for constructing commands.

This example project has a simple model in models.py.  Have a look at manage.py as well.

On first installation (a one time operation), you would run

```
python manage.py db init
```

This creates a migration directory with files needed for Alembic

You can then run

```
python manage.py db migrate
```

That will dump a file into the versions directory in migrations. In manage.py script there's an import for all the models in models.py.

The file created in versions contains the python code needed to create tables based upon your models.

Below is a snippet from the example migration script in project.

```
def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.create_table('foo',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('fooname', sa.String(length=140), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('fooname')
    )
```

To apply the change to your local db, be that sqlite or postgres or whatever you've configured in base Config class, then run.

```
python manage.py db upgrade
```

To run the migration on heroku you just need to have set the correct configuration class using heroku config:set as mentioned above. Push the repo to Heroku
and then use

```
heroku run ...
```

to run the commands as above.


### Frontend and static assets

TODO
